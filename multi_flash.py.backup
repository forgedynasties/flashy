"""Multi-device flasher TUI application."""

from textual.app import App, ComposeResult
from textual.containers import Container, Vertical, Horizontal, ScrollableContainer
from textual.widgets import Header, Footer, Static, Input, DataTable, Log, Label
from textual.binding import Binding
from textual import work
from typing import List, Dict, Set
import os
from pathlib import Path
import time
import asyncio
from datetime import datetime, timedelta

from backend import get_qualcomm_serials, flash_device


def get_adb_devices() -> List[str]:
    """Get list of connected ADB devices."""
    import subprocess
    try:
        result = subprocess.run(
            ["adb", "devices"],
            capture_output=True,
            text=True,
            timeout=5
        )
        devices = []
        for line in result.stdout.strip().split('\n')[1:]:  # Skip header
            line = line.strip()
            if line and not line.startswith("*"):
                parts = line.split()
                if len(parts) >= 2 and parts[1] == "device":
                    devices.append(parts[0])
        return devices
    except Exception:
        return []


def adb_reboot_edl(device: str) -> bool:
    """Reboot ADB device to EDL mode."""
    import subprocess
    try:
        subprocess.run(
            ["adb", "-s", device, "reboot", "edl"],
            capture_output=True,
            timeout=10
        )
        return True
    except Exception:
        return False


class DeviceFlasher(App):
    """Multi-device Qualcomm flasher TUI with parallel flashing."""
    
    CSS = """
    Screen {
        layout: grid;
        grid-size: 4 2;
        grid-rows: auto 1fr;
    }
    
    #top-panel {
        column-span: 4;
        row-span: 1;
        height: auto;
        border: solid $accent;
        padding: 1;
    }
    
    #adb-panel {
        column-span: 1;
        row-span: 1;
        border: solid $accent;
        height: 100%;
    }
    
    #devices-panel {
        column-span: 1;
        row-span: 1;
        border: solid $accent;
        height: 100%;
    }
    
    #progress-container {
        column-span: 2;
        row-span: 1;
        border: solid $accent;
        height: 100%;
    }
    
    #status-bar {
        dock: bottom;
        height: 3;
        background: $boost;
        padding: 1;
    }
    
    .panel-title {
        background: $accent;
        color: $text;
        padding: 0 1;
        text-align: center;
        text-style: bold;
        width: 100%;
    }
    
    #firmware-input {
        width: 1fr;
        margin: 0 1;
    }
    
    DataTable {
        height: 1fr;
    }
    
    #progress-logs-container {
        height: 1fr;
        border: none;
    }
    
    .device-log {
        height: 1fr;
        border: solid $primary;
        margin: 0 0 0 0;
    }
    
    .device-log-title {
        background: $boost;
        padding: 0 1;
        text-style: bold;
        width: 100%;
    }
    """
    
    BINDINGS = [
        Binding("q", "quit", "Quit"),
        Binding("r", "refresh_devices", "Refresh"),
        Binding("space", "toggle_device", "Select"),
        Binding("f", "start_flash", "Flash", show=True),
        Binding("e", "reboot_edl", "Reboot EDL", show=True),
        Binding("tab", "focus_next", "Next", show=False),
        Binding("shift+tab", "focus_previous", "Prev", show=False),
    ]
    
    def __init__(self):
        super().__init__()
        self.devices: List[str] = []
        self.selected_devices: Set[str] = set()
        self.adb_devices: List[str] = []
        self.firmware_path: str = ""
        self.auto_refresh_enabled = True
        self.flashing_devices: Dict[str, bool] = {}
        self.flash_results: Dict[str, int] = {}
        self.device_logs: Dict[str, Log] = {}  # separate log per device
        self.flash_start_times: Dict[str, float] = {}  # device -> start time
        self.flash_end_times: Dict[str, float] = {}  # device -> end time
    
    def compose(self) -> ComposeResult:
        yield Header()
        
        # Top Panel: Firmware input
        with Vertical(id="top-panel"):
            yield Static("ðŸ“‚ Firmware Path", classes="panel-title")
            yield Input(
                placeholder="Enter firmware directory path",
                id="firmware-input"
            )
            yield Static(
                "SPACE to select QDL devices, E to reboot ADB to EDL, F to flash, R to refresh",
                id="help-text"
            )
        
        # ADB Panel
        with Vertical(id="adb-panel"):
            yield Static("ðŸ“± ADB Devices (E to reboot)", classes="panel-title")
            yield DataTable(id="adb-table")
        
        # QDL Devices Panel
        with Vertical(id="devices-panel"):
            yield Static("âš¡ QDL Devices (SPACE to select)", classes="panel-title")
            yield DataTable(id="devices-table")
        
        # Right Panel: Parallel progress logs (dynamic)
        with Vertical(id="progress-container"):
            yield Static("âš¡ Flash Progress (Parallel)", classes="panel-title")
            yield ScrollableContainer(
                Horizontal(id="progress-logs-container"),
                id="progress-scroll"
            )
        
        # Status bar
        yield Container(
            Label("Ready", id="status-label"),
            id="status-bar"
        )
        
        yield Footer()
    
    def on_mount(self) -> None:
        """Initialize app on mount."""
        # Setup ADB table
        adb_table = self.query_one("#adb-table", DataTable)
        adb_table.cursor_type = "row"
        adb_table.zebra_stripes = True
        
        # Setup QDL devices table
        table = self.query_one("#devices-table", DataTable)
        table.cursor_type = "row"
        table.zebra_stripes = True
        
        # Setup firmware input
        fw_input = self.query_one("#firmware-input", Input)
        fw_input.value = "/home/hwpc/firmware/nfc-debug/qfil_download_emmc/"
        
        # Refresh both device lists
        self.refresh_adb_devices()
        self.refresh_devices_table()
        
        # Start auto-refresh
        self.start_auto_refresh()
    
    @work(thread=True)
    def start_auto_refresh(self) -> None:
        """Background thread to auto-refresh device list."""
        while self.auto_refresh_enabled:
            time.sleep(2)
            
            try:
                current_devices = get_qualcomm_serials()
                current_adb = get_adb_devices()
                
                if set(current_devices) != set(self.devices) or set(current_adb) != set(self.adb_devices):
                    self.call_from_thread(self.update_devices_list, current_devices, current_adb)
                    
            except Exception:
                pass
    
    def update_devices_list(self, new_devices: List[str], new_adb: List[str]) -> None:
        """Update device list when changes detected."""
        added = set(new_devices) - set(self.devices)
        removed = set(self.devices) - set(new_devices)
        
        adb_added = set(new_adb) - set(self.adb_devices)
        adb_removed = set(self.adb_devices) - set(new_adb)
        
        if added or removed:
            if added:
                for dev in added:
                    os.system('play -nq -t alsa synth 0.1 sine 800 2>/dev/null &')
            
            if removed:
                for dev in removed:
                    os.system('play -nq -t alsa synth 0.1 sine 400 2>/dev/null &')
                    self.selected_devices.discard(dev)
                    if dev in self.device_logs:
                        del self.device_logs[dev]
            
            self.devices = new_devices
            self.refresh_devices_table(silent=True)
        
        if adb_added or adb_removed:
            self.adb_devices = new_adb
            self.refresh_adb_devices(silent=True)
    
    def refresh_devices_table(self, silent: bool = False) -> None:
        """Refresh the devices table."""
        table = self.query_one("#devices-table", DataTable)
        
        table.clear(columns=True)
        table.add_columns("Device", "Status", "Result")
        
        try:
            if not silent:
                self.devices = get_qualcomm_serials()
            
            if not self.devices:
                table.add_row("â€”", "â€”", "â€”")
            else:
                for serial in self.devices:
                    status = "âœ“ Selected" if serial in self.selected_devices else "â—‹ Ready"
                    result = self.flash_results.get(serial, "â€”")
                    table.add_row(serial, status, str(result))
        
        except Exception as e:
            table.add_row("Error", "â€”", "â€”")
        
        self.update_status(f"QDL: {len(self.devices)} | ADB: {len(self.adb_devices)} | Selected: {len(self.selected_devices)}")
    
    def refresh_adb_devices(self, silent: bool = False) -> None:
        """Refresh the ADB devices table."""
        table = self.query_one("#adb-table", DataTable)
        
        table.clear(columns=True)
        table.add_columns("ADB Device", "Status")
        
        try:
            if not silent:
                self.adb_devices = get_adb_devices()
            
            if not self.adb_devices:
                table.add_row("â€”", "â€”")
            else:
                for device in self.adb_devices:
                    table.add_row(device, "Online")
        
        except Exception:
            table.add_row("Error", "â€”")
    
    def on_data_table_row_selected(self, event: DataTable.RowSelected) -> None:
        """Handle row selection."""
        if self.devices and event.cursor_row < len(self.devices):
            serial = self.devices[event.cursor_row]
            self.selected_devices.discard(serial)  # deselect on click
            self.refresh_devices_table(silent=True)
    
    def action_toggle_device(self) -> None:
        """Toggle device selection with SPACE."""
        if not self.devices:
            return
        
        table = self.query_one("#devices-table", DataTable)
        
        try:
            row = table.cursor_row
            if row < len(self.devices):
                serial = self.devices[row]
                if serial in self.selected_devices:
                    self.selected_devices.remove(serial)
                else:
                    self.selected_devices.add(serial)
                
                self.refresh_devices_table(silent=True)
        except Exception:
            pass
    
    def action_refresh_devices(self) -> None:
        """Manually refresh devices."""
        self.refresh_devices_table()
        self.refresh_adb_devices()
    
    def action_reboot_edl(self) -> None:
        """Reboot all ADB devices to EDL mode."""
        if not self.adb_devices:
            self.update_status("[red]No ADB devices found![/red]")
            return
        
        self.update_status(f"[yellow]Rebooting {len(self.adb_devices)} ADB device(s) to EDL...[/yellow]")
        self.reboot_adb_devices_edl()
    
    @work(thread=True)
    def reboot_adb_devices_edl(self) -> None:
        """Reboot all ADB devices to EDL in parallel."""
        import subprocess
        
        for device in self.adb_devices:
            try:
                subprocess.run(
                    ["adb", "-s", device, "reboot", "edl"],
                    capture_output=True,
                    timeout=10
                )
                self.call_from_thread(
                    self.update_status,
                    f"[green]Rebooted {device} to EDL[/green]"
                )
            except Exception as e:
                self.call_from_thread(
                    self.update_status,
                    f"[red]Failed to reboot {device}: {e}[/red]"
                )
        
        # Wait for devices to appear in QDL
        time.sleep(3)
        self.call_from_thread(self.refresh_devices_table)
        self.call_from_thread(self.refresh_adb_devices)
    
    def action_start_flash(self) -> None:
        """Start flashing all selected devices in parallel."""
        fw_input = self.query_one("#firmware-input", Input)
        
        self.firmware_path = fw_input.value.strip()
        
        if not self.firmware_path:
            self.update_status("[red]Firmware path required![/red]")
            return
        
        if not Path(self.firmware_path).is_dir():
            self.update_status(f"[red]Path not found: {self.firmware_path}[/red]")
            return
        
        if not self.selected_devices:
            self.update_status("[red]No devices selected![/red]")
            return
        
        # Create progress panes for each device
        self.create_progress_panes()
        
        # Start all flashes in parallel
        for serial in self.selected_devices:
            self.flash_device_parallel(serial, self.firmware_path)
        
        self.update_status(f"Flashing {len(self.selected_devices)} device(s) in parallel...")
    
    def create_progress_panes(self) -> None:
        """Create individual progress panes for each selected device."""
        container = self.query_one("#progress-logs-container", Horizontal)
        
        # Clear all children
        for child in list(container.children):
            child.remove()
        
        self.device_logs.clear()
        self.flash_start_times.clear()
        self.flash_end_times.clear()
        
        # Create a pane for each selected device
        for serial in sorted(self.selected_devices):
            # Create vertical container for each device
            device_pane = Vertical(classes="device-log")
            
            # Title with placeholder for time
            title = Static(f"[bold]{serial}[/bold] [dim](waiting...)[/dim]", id=f"title-{serial}", classes="device-log-title")
            
            # Log for this device
            log = Log()
            log.write_line(f"[bold cyan]â³ Starting...[/bold cyan]")
            
            self.device_logs[serial] = log
            
            # Mount device_pane to container first, then mount children
            container.mount(device_pane)
            device_pane.mount(title, log)
    
    @work(thread=True)
    def flash_device_parallel(self, serial: str, firmware_path: str) -> None:
        """Flash a device in parallel."""
        log = self.device_logs.get(serial)
        if not log:
            return
        
        self.flashing_devices[serial] = True
        start_time = time.time()
        self.flash_start_times[serial] = start_time
        
        # Update title with start time
        self.call_from_thread(self.update_device_title, serial, start_time, None)
        
        try:
            output_lines = 0
            
            def output_cb(line: str):
                nonlocal output_lines
                if log:
                    log.write_line(line)
                    output_lines += 1
                    # Update title every 5 lines with elapsed time
                    if output_lines % 5 == 0:
                        elapsed = time.time() - start_time
                        self.call_from_thread(self.update_device_title, serial, start_time, elapsed)
            
            log.write_line(f"[dim]Starting flash...[/dim]")
            
            returncode = flash_device(serial, firmware_path, output_callback=output_cb)
            self.flash_results[serial] = returncode
            
            end_time = time.time()
            self.flash_end_times[serial] = end_time
            elapsed = end_time - start_time
            
            if returncode == 0:
                log.write_line(f"[bold green]âœ“ Success in {self.format_time(elapsed)}![/bold green]")
                os.system('play -nq -t alsa synth 0.5 sine 440 2>/dev/null')
                self.call_from_thread(self.update_device_title, serial, start_time, elapsed, "âœ“")
            else:
                log.write_line(f"[bold red]âœ— Failed after {self.format_time(elapsed)} (code {returncode})[/bold red]")
                os.system('play -nq -t alsa synth 0.5 sine 220 2>/dev/null')
                self.call_from_thread(self.update_device_title, serial, start_time, elapsed, "âœ—")
        
        except Exception as e:
            end_time = time.time()
            elapsed = end_time - start_time
            log.write_line(f"[bold red]âœ— Error after {self.format_time(elapsed)}: {e}[/bold red]")
            self.flash_results[serial] = -1
            self.flash_end_times[serial] = end_time
            os.system('play -nq -t alsa synth 0.5 sine 220 2>/dev/null')
            self.call_from_thread(self.update_device_title, serial, start_time, elapsed, "âœ—")
        
        finally:
            self.flashing_devices[serial] = False
            self.call_from_thread(self.refresh_devices_table, True)
    
    def update_device_title(self, serial: str, start_time: float, elapsed: float = None, status: str = None) -> None:
        """Update device pane title with elapsed time."""
        try:
            title = self.query_one(f"#title-{serial}", Static)
            
            if status:
                # Final status
                time_str = self.format_time(elapsed) if elapsed else "0s"
                title.update(f"[bold]{status} {serial}[/bold] [bold green]{time_str}[/bold green]")
            elif elapsed is not None:
                # Still flashing, show elapsed
                time_str = self.format_time(elapsed)
                title.update(f"[bold]{serial}[/bold] [dim]â± {time_str}[/dim]")
            else:
                # Not started yet
                title.update(f"[bold]{serial}[/bold] [dim](queued...)[/dim]")
        except Exception:
            pass
    
    @staticmethod
    def format_time(seconds: float) -> str:
        """Format seconds to mm:ss or h:mm:ss format."""
        if seconds < 0:
            seconds = 0
        
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        
        if hours > 0:
            return f"{hours}h {minutes:02d}m {secs:02d}s"
        else:
            return f"{minutes:02d}m {secs:02d}s"
    
    def update_status(self, message: str) -> None:
        """Update status bar."""
        status = self.query_one("#status-label", Label)
        status.update(f"Status: {message}")
    
    def on_unmount(self) -> None:
        """Cleanup on exit."""
        self.auto_refresh_enabled = False


if __name__ == "__main__":
    app = DeviceFlasher()
    app.run()
